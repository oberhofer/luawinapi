//////////////////////////////////////////////////////////////////////////
/**

  luawinapi - winapi wrapper for Lua
  Copyright (C) 2011 Klaus Oberhofer. See copyright notice in
  LICENSE file
  
  $(generatedbymessage)

*/////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>

#ifdef USE_AYGSHELL
#include <aygshell.h>
#endif

#ifdef UNDER_CE
#include <pm.h>
#include <connmgr.h>
#endif

#include <commdlg.h>

#include "gdihelpers.h"

#include "gen_structs.h"
#include "gen_abstractions.h"

#include "mingw_structs.h"

#include "utfstrconvert.h"
#include "luatypeconvert.h"

// luacwrap c interface
extern luacwrap_cinterface* g_luacwrapiface;

// TODO: type descriptors for OS specific types (like INT_PTR, LRESULT) to enable
// expressions like #winapi.LRESULT


// array type descriptors
//#for name, arr in pairs(arraydefs) do
//#  local basic_type = basic_types[result] or basic_alias
static struct luacwrap_ArrayType regType_$(name) =
{
  LUACWRAP_TC_ARRAY,
  "$(name)",
  $(arr.len),
  sizeof($(arr.alias)),
  "$(arr.typ)"
};

//#end

// member descriptors
//#for _, struct in pairs(structdefs) do

//#     prerequisite_begin(struct, _put)
static luacwrap_RecordMember s_member$(struct.name)[] =
{
//#  for _, member in ipairs(struct.members) do
//#     prerequisite_begin(member, _put)
  { "$(member.name)", offsetof($(struct.name), $(member.name)), "$(get_descriptor_id(member))"},
//#     prerequisite_end(member, _put)
//#  end
  { NULL, 0 }
};

LUACWRAP_DEFINESTRUCT($(struct.name));
//#     prerequisite_end(struct, _put)
//#end

//////////////////////////////////////////////////////////////////////////
/**

  helper functions to get pointer to DefDlgProc and DefWindowProc

*/////////////////////////////////////////////////////////////////////////

static int winapi_GetDefDlgProcW(lua_State* L)
{
  lua_pushlightuserdata(L,DefDlgProcW);
  return 1;
}

static int winapi_GetDefWindowProcW(lua_State* L)
{
  lua_pushlightuserdata(L,DefWindowProcW);
  return 1;
}

//////////////////////////////////////////////////////////////////////////
/**

  helper functions to process messages (msg loop implementation)

*/////////////////////////////////////////////////////////////////////////

int winapi_ProcessMessages( lua_State *L )
{
  MSG msg;
  while(GetMessage(&msg, NULL, 0, 0))
  {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
  }

  lua_pushnumber(L, msg.wParam);
  return 1;
}

//////////////////////////////////////////////////////////////////////////
/**

  helper functions for UNICODE/UTF8 conversion

*/////////////////////////////////////////////////////////////////////////

static int widestringfromutf8(lua_State* L)
{
  winapi_widestringfromutf8_Z(L, 1, NULL);
  return 1;
}

static int utf8fromwidestring(lua_State* L)
{
  winapi_utf8fromwidestring_Z(L, 1, NULL);
  return 1;
}

//////////////////////////////////////////////////////////////////////////
/**

  generated wrappers

*/////////////////////////////////////////////////////////////////////////

//#  for _, func in ipairs(funcdefs) do
//#    if (not attribs_contains(func, "skipimpl")) then
//#      prerequisite_begin(func, _put)
int winapi_$(func.name)( lua_State *L )
{
  int numret = 0;
//# if (func.rettype ~= "VOID") then
  $(func.rettype) retval;
//# end
//# for i, param in ipairs(func.params) do
//#   local pname = param.name or ("p" .. i)
  $(declare_param(param, pname))
//# end

//#-- marshal parameter
//# for i, param in ipairs(func.params) do
//#   local pname = param.name or ("p" .. i) 
//#   local init = init_param(param, "in", pname, i)
//#   if ("" ~= init) then
//#   else
//#     -- marshal parameter
//#     local val = attribs_value(param, "ommit");
//#     if (val) then
  $(pname) = $(val);
//#     else
  $(marshal_param(param, "in", pname, i))
//#     end
//#   end
//# end

//#-- init parameter
//# for i, param in ipairs(func.params) do
//#   local pname = param.name or ("p" .. i)
//#   local init = init_param(param, "in", pname, i)
//#   if ("" ~= init) then
  $(init)
//#   else
//#   end
//# end

//# if (func.rettype ~= "VOID") then
  retval = 
//# end
    $(func.name)(
//# for i, param in ipairs(func.params) do
//#   local pname = param.name or ("p" .. i)
//#   local postfix = ","
//#   if (i == #func.params) then postfix = "" end
      $(use_param(param, pname))$(postfix)
//# end
    );
//# if (func.rettype ~= "VOID") then

  // marshal retval
  $(marshal_param(func.rettype, "out", "retval", nil))
//# end
//# -- marshal out params
//# for i, param in ipairs(func.params) do
//#   local pname = param.name or ("p" .. i)
//#   if (attribs_contains(param, "out")) then

  $(marshal_param(param, "out", pname, i))
//#   end
//# end

  return numret;
}

//#      prerequisite_end(func, _put)
//#    end
//#  end

static const luaL_Reg module_lib[ ] = {
  { "GetDefDlgProcW"    , winapi_GetDefDlgProcW  },
  { "GetDefWindowProcW" , winapi_GetDefWindowProcW },
  { "ProcessMessages"   , winapi_ProcessMessages },
  
  { "widestringfromutf8", widestringfromutf8 },
  { "utf8fromwidestring", utf8fromwidestring },

//#  for _, func in ipairs(funcdefs) do
//#     prerequisite_begin(func, _put)
  { "$(func.name)",  winapi_$(func.name) },
//#     prerequisite_end(func, _put)
//#  end
  
  { NULL, NULL }
};


//////////////////////////////////////////////////////////////////////////
/**

  registers structures as Lua types

  @param[in]  L  pointer lua state

*/////////////////////////////////////////////////////////////////////////
int register_luawinapi(lua_State *L)
{
  // index of module table
  int M = lua_gettop(L);

  // register package functions
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, module_lib, 0);
#else
  luaL_openlib(L, NULL, module_lib, 0);
#endif

  // register array types
//#for name, arr in pairs(arraydefs) do
  g_luacwrapiface->registertype(L, M, &regType_$(name).hdr);
//#end
  
  // register structure types
//#for _, struct in pairs(structdefs) do
//#     prerequisite_begin(struct, _put)
  g_luacwrapiface->registertype(L, M, &regType_$(struct.name).hdr);
//#     prerequisite_end(struct, _put)
//#end

  winapi_RegisterWndProc(L);

  registerAbstractions(L);
  
  return 1;
}


