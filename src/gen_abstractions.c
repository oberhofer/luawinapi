//////////////////////////////////////////////////////////////////////////
/**

  luawinapi - winapi wrapper for Lua
  Copyright (C) 2011 Klaus Oberhofer. See copyright notice in
  LICENSE file
  
  !!! This file is generated by genwrap.lua  !!!

*/////////////////////////////////////////////////////////////////////////

#include <windows.h>

#ifdef USE_AYGSHELL
#include <aygshell.h>
#endif

#include "gen_abstractions.h"
#include "gen_structs.h"

#if (defined(USE_MSGQUEUE))
// used to identify the type
const char* MsgQueue_Typename = "MsgQueue";

// push on stack
int lua_pushMsgQueue( lua_State *L, HMSGQUEUE hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, MsgQueue_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HMSGQUEUE* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HMSGQUEUE*)lua_newuserdata(L, sizeof(HMSGQUEUE));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HMSGQUEUE lua_toMsgQueue( lua_State *L, int idx )
{
  HMSGQUEUE v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HMSGQUEUE)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HMSGQUEUE)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HMSGQUEUE* ud  = (HMSGQUEUE*)luaL_checkudata(L, idx, MsgQueue_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "MsgQueue (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int MsgQueue_index(lua_State *L)
{
  HMSGQUEUE* ud  = (HMSGQUEUE*)luaL_checkudata(L, 1, MsgQueue_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int MsgQueue_wrap(lua_State *L)
{
  HMSGQUEUE handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HMSGQUEUE)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HMSGQUEUE)luaL_checkudata(L, -1, MsgQueue_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HMSGQUEUE)lua_tointeger(L, -1);
  }
  
  return lua_pushMsgQueue(L, handle);
}


static const struct luaL_Reg MsgQueue_Methods[ ] = {
  { "__index", MsgQueue_index},
  { "wrap", MsgQueue_wrap },
#if (defined(USE_MSGQUEUE))
  { "ReadMsgQueue",  winapi_ReadMsgQueue },
#endif
#if (defined(USE_MSGQUEUE))
  { "WriteMsgQueue",  winapi_WriteMsgQueue },
#endif
#if (defined(USE_MSGQUEUE))
  { "GetMsgQueueInfo",  winapi_GetMsgQueueInfo },
#endif
#if (defined(USE_MSGQUEUE))
  { "CloseMsgQueue",  winapi_CloseMsgQueue },
#endif
  { NULL, NULL }
};

static const struct luaL_Reg MsgQueue_WrapMethods[ ] = {
  { "WrapMsgQueue", MsgQueue_wrap },
  { NULL, NULL }
};

#endif
// used to identify the type
const char* Driver_Typename = "Driver";

// push on stack
int lua_pushDriver( lua_State *L, HDRVR hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, Driver_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HDRVR* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HDRVR*)lua_newuserdata(L, sizeof(HDRVR));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HDRVR lua_toDriver( lua_State *L, int idx )
{
  HDRVR v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HDRVR)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HDRVR)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HDRVR* ud  = (HDRVR*)luaL_checkudata(L, idx, Driver_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "Driver (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int Driver_index(lua_State *L)
{
  HDRVR* ud  = (HDRVR*)luaL_checkudata(L, 1, Driver_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int Driver_wrap(lua_State *L)
{
  HDRVR handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HDRVR)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HDRVR)luaL_checkudata(L, -1, Driver_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HDRVR)lua_tointeger(L, -1);
  }
  
  return lua_pushDriver(L, handle);
}


static const struct luaL_Reg Driver_Methods[ ] = {
  { "__index", Driver_index},
  { "wrap", Driver_wrap },
  { NULL, NULL }
};

static const struct luaL_Reg Driver_WrapMethods[ ] = {
  { "WrapDriver", Driver_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* WaveOut_Typename = "WaveOut";

// push on stack
int lua_pushWaveOut( lua_State *L, HWAVEOUT hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, WaveOut_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HWAVEOUT* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HWAVEOUT*)lua_newuserdata(L, sizeof(HWAVEOUT));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HWAVEOUT lua_toWaveOut( lua_State *L, int idx )
{
  HWAVEOUT v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HWAVEOUT)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HWAVEOUT)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HWAVEOUT* ud  = (HWAVEOUT*)luaL_checkudata(L, idx, WaveOut_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "WaveOut (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int WaveOut_index(lua_State *L)
{
  HWAVEOUT* ud  = (HWAVEOUT*)luaL_checkudata(L, 1, WaveOut_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int WaveOut_wrap(lua_State *L)
{
  HWAVEOUT handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HWAVEOUT)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HWAVEOUT)luaL_checkudata(L, -1, WaveOut_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HWAVEOUT)lua_tointeger(L, -1);
  }
  
  return lua_pushWaveOut(L, handle);
}


static const struct luaL_Reg WaveOut_Methods[ ] = {
  { "__index", WaveOut_index},
  { "wrap", WaveOut_wrap },
  { "waveOutGetVolume",  winapi_waveOutGetVolume },
  { "waveOutSetVolume",  winapi_waveOutSetVolume },
  { "waveOutOpen",  winapi_waveOutOpen },
  { "waveOutClose",  winapi_waveOutClose },
  { "waveOutPrepareHeader",  winapi_waveOutPrepareHeader },
  { "waveOutUnprepareHeader",  winapi_waveOutUnprepareHeader },
  { "waveOutWrite",  winapi_waveOutWrite },
  { "waveOutPause",  winapi_waveOutPause },
  { "waveOutRestart",  winapi_waveOutRestart },
  { "waveOutReset",  winapi_waveOutReset },
  { "waveOutBreakLoop",  winapi_waveOutBreakLoop },
  { "waveOutGetPosition",  winapi_waveOutGetPosition },
  { "waveOutGetPitch",  winapi_waveOutGetPitch },
  { "waveOutSetPitch",  winapi_waveOutSetPitch },
  { "waveOutGetPlaybackRate",  winapi_waveOutGetPlaybackRate },
  { "waveOutSetPlaybackRate",  winapi_waveOutSetPlaybackRate },
  { "waveOutGetID",  winapi_waveOutGetID },
  { "waveOutMessage",  winapi_waveOutMessage },
  { NULL, NULL }
};

static const struct luaL_Reg WaveOut_WrapMethods[ ] = {
  { "WrapWaveOut", WaveOut_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* MixerObject_Typename = "MixerObject";

// push on stack
int lua_pushMixerObject( lua_State *L, HMIXEROBJ hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, MixerObject_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HMIXEROBJ* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HMIXEROBJ*)lua_newuserdata(L, sizeof(HMIXEROBJ));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HMIXEROBJ lua_toMixerObject( lua_State *L, int idx )
{
  HMIXEROBJ v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HMIXEROBJ)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HMIXEROBJ)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HMIXEROBJ* ud  = (HMIXEROBJ*)luaL_checkudata(L, idx, MixerObject_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "MixerObject (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int MixerObject_index(lua_State *L)
{
  HMIXEROBJ* ud  = (HMIXEROBJ*)luaL_checkudata(L, 1, MixerObject_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int MixerObject_wrap(lua_State *L)
{
  HMIXEROBJ handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HMIXEROBJ)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HMIXEROBJ)luaL_checkudata(L, -1, MixerObject_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HMIXEROBJ)lua_tointeger(L, -1);
  }
  
  return lua_pushMixerObject(L, handle);
}


static const struct luaL_Reg MixerObject_Methods[ ] = {
  { "__index", MixerObject_index},
  { "wrap", MixerObject_wrap },
  { "mixerGetLineInfoW",  winapi_mixerGetLineInfoW },
  { "mixerGetLineControlsW",  winapi_mixerGetLineControlsW },
  { "mixerGetControlDetailsW",  winapi_mixerGetControlDetailsW },
  { "mixerSetControlDetails",  winapi_mixerSetControlDetails },
  { NULL, NULL }
};

static const struct luaL_Reg MixerObject_WrapMethods[ ] = {
  { "WrapMixerObject", MixerObject_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* WaveIn_Typename = "WaveIn";

// push on stack
int lua_pushWaveIn( lua_State *L, HWAVEIN hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, WaveIn_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HWAVEIN* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HWAVEIN*)lua_newuserdata(L, sizeof(HWAVEIN));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HWAVEIN lua_toWaveIn( lua_State *L, int idx )
{
  HWAVEIN v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HWAVEIN)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HWAVEIN)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HWAVEIN* ud  = (HWAVEIN*)luaL_checkudata(L, idx, WaveIn_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "WaveIn (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int WaveIn_index(lua_State *L)
{
  HWAVEIN* ud  = (HWAVEIN*)luaL_checkudata(L, 1, WaveIn_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int WaveIn_wrap(lua_State *L)
{
  HWAVEIN handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HWAVEIN)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HWAVEIN)luaL_checkudata(L, -1, WaveIn_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HWAVEIN)lua_tointeger(L, -1);
  }
  
  return lua_pushWaveIn(L, handle);
}


static const struct luaL_Reg WaveIn_Methods[ ] = {
  { "__index", WaveIn_index},
  { "wrap", WaveIn_wrap },
  { "waveInOpen",  winapi_waveInOpen },
  { "waveInClose",  winapi_waveInClose },
  { "waveInPrepareHeader",  winapi_waveInPrepareHeader },
  { "waveInUnprepareHeader",  winapi_waveInUnprepareHeader },
  { "waveInAddBuffer",  winapi_waveInAddBuffer },
  { "waveInStart",  winapi_waveInStart },
  { "waveInStop",  winapi_waveInStop },
  { "waveInReset",  winapi_waveInReset },
  { "waveInGetPosition",  winapi_waveInGetPosition },
  { "waveInGetID",  winapi_waveInGetID },
  { "waveInMessage",  winapi_waveInMessage },
  { NULL, NULL }
};

static const struct luaL_Reg WaveIn_WrapMethods[ ] = {
  { "WrapWaveIn", WaveIn_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* Mixer_Typename = "Mixer";

// push on stack
int lua_pushMixer( lua_State *L, HMIXER hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, Mixer_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HMIXER* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HMIXER*)lua_newuserdata(L, sizeof(HMIXER));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HMIXER lua_toMixer( lua_State *L, int idx )
{
  HMIXER v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HMIXER)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HMIXER)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HMIXER* ud  = (HMIXER*)luaL_checkudata(L, idx, Mixer_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "Mixer (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int Mixer_index(lua_State *L)
{
  HMIXER* ud  = (HMIXER*)luaL_checkudata(L, 1, Mixer_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int Mixer_wrap(lua_State *L)
{
  HMIXER handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HMIXER)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HMIXER)luaL_checkudata(L, -1, Mixer_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HMIXER)lua_tointeger(L, -1);
  }
  
  return lua_pushMixer(L, handle);
}


static const struct luaL_Reg Mixer_Methods[ ] = {
  { "__index", Mixer_index},
  { "wrap", Mixer_wrap },
  { "mixerOpen",  winapi_mixerOpen },
  { "mixerClose",  winapi_mixerClose },
  { "mixerMessage",  winapi_mixerMessage },
  { NULL, NULL }
};

static const struct luaL_Reg Mixer_WrapMethods[ ] = {
  { "WrapMixer", Mixer_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* MidiStream_Typename = "MidiStream";

// push on stack
int lua_pushMidiStream( lua_State *L, HMIDISTRM hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, MidiStream_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HMIDISTRM* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HMIDISTRM*)lua_newuserdata(L, sizeof(HMIDISTRM));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HMIDISTRM lua_toMidiStream( lua_State *L, int idx )
{
  HMIDISTRM v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HMIDISTRM)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HMIDISTRM)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HMIDISTRM* ud  = (HMIDISTRM*)luaL_checkudata(L, idx, MidiStream_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "MidiStream (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int MidiStream_index(lua_State *L)
{
  HMIDISTRM* ud  = (HMIDISTRM*)luaL_checkudata(L, 1, MidiStream_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int MidiStream_wrap(lua_State *L)
{
  HMIDISTRM handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HMIDISTRM)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HMIDISTRM)luaL_checkudata(L, -1, MidiStream_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HMIDISTRM)lua_tointeger(L, -1);
  }
  
  return lua_pushMidiStream(L, handle);
}


static const struct luaL_Reg MidiStream_Methods[ ] = {
  { "__index", MidiStream_index},
  { "wrap", MidiStream_wrap },
  { "midiStreamOpen",  winapi_midiStreamOpen },
  { "midiStreamClose",  winapi_midiStreamClose },
  { "midiStreamProperty",  winapi_midiStreamProperty },
  { "midiStreamPosition",  winapi_midiStreamPosition },
  { "midiStreamOut",  winapi_midiStreamOut },
  { "midiStreamPause",  winapi_midiStreamPause },
  { "midiStreamRestart",  winapi_midiStreamRestart },
  { "midiStreamStop",  winapi_midiStreamStop },
  { NULL, NULL }
};

static const struct luaL_Reg MidiStream_WrapMethods[ ] = {
  { "WrapMidiStream", MidiStream_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* MidiIn_Typename = "MidiIn";

// push on stack
int lua_pushMidiIn( lua_State *L, HMIDIIN hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, MidiIn_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HMIDIIN* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HMIDIIN*)lua_newuserdata(L, sizeof(HMIDIIN));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HMIDIIN lua_toMidiIn( lua_State *L, int idx )
{
  HMIDIIN v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HMIDIIN)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HMIDIIN)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HMIDIIN* ud  = (HMIDIIN*)luaL_checkudata(L, idx, MidiIn_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "MidiIn (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int MidiIn_index(lua_State *L)
{
  HMIDIIN* ud  = (HMIDIIN*)luaL_checkudata(L, 1, MidiIn_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int MidiIn_wrap(lua_State *L)
{
  HMIDIIN handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HMIDIIN)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HMIDIIN)luaL_checkudata(L, -1, MidiIn_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HMIDIIN)lua_tointeger(L, -1);
  }
  
  return lua_pushMidiIn(L, handle);
}


static const struct luaL_Reg MidiIn_Methods[ ] = {
  { "__index", MidiIn_index},
  { "wrap", MidiIn_wrap },
  { "midiInOpen",  winapi_midiInOpen },
  { "midiInClose",  winapi_midiInClose },
  { "midiInPrepareHeader",  winapi_midiInPrepareHeader },
  { "midiInUnprepareHeader",  winapi_midiInUnprepareHeader },
  { "midiInAddBuffer",  winapi_midiInAddBuffer },
  { "midiInStart",  winapi_midiInStart },
  { "midiInStop",  winapi_midiInStop },
  { "midiInReset",  winapi_midiInReset },
  { "midiInGetID",  winapi_midiInGetID },
  { "midiInMessage",  winapi_midiInMessage },
  { NULL, NULL }
};

static const struct luaL_Reg MidiIn_WrapMethods[ ] = {
  { "WrapMidiIn", MidiIn_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* Icon_Typename = "Icon";

// push on stack
int lua_pushIcon( lua_State *L, HICON hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, Icon_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HICON* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HICON*)lua_newuserdata(L, sizeof(HICON));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HICON lua_toIcon( lua_State *L, int idx )
{
  HICON v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HICON)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HICON)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HICON* ud  = (HICON*)luaL_checkudata(L, idx, Icon_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "Icon (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int Icon_index(lua_State *L)
{
  HICON* ud  = (HICON*)luaL_checkudata(L, 1, Icon_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int Icon_wrap(lua_State *L)
{
  HICON handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HICON)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HICON)luaL_checkudata(L, -1, Icon_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HICON)lua_tointeger(L, -1);
  }
  
  return lua_pushIcon(L, handle);
}


static const struct luaL_Reg Icon_Methods[ ] = {
  { "__index", Icon_index},
  { "wrap", Icon_wrap },
  { "DestroyIcon",  winapi_DestroyIcon },
  { NULL, NULL }
};

static const struct luaL_Reg Icon_WrapMethods[ ] = {
  { "WrapIcon", Icon_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* Window_Typename = "Window";

// push on stack
int lua_pushWindow( lua_State *L, HWND hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, Window_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HWND* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HWND*)lua_newuserdata(L, sizeof(HWND));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HWND lua_toWindow( lua_State *L, int idx )
{
  HWND v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HWND)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HWND)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HWND* ud  = (HWND*)luaL_checkudata(L, idx, Window_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "Window (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int Window_index(lua_State *L)
{
  HWND* ud  = (HWND*)luaL_checkudata(L, 1, Window_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int Window_wrap(lua_State *L)
{
  HWND handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HWND)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HWND)luaL_checkudata(L, -1, Window_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HWND)lua_tointeger(L, -1);
  }
  
  return lua_pushWindow(L, handle);
}


static const struct luaL_Reg Window_Methods[ ] = {
  { "__index", Window_index},
  { "wrap", Window_wrap },
  { "IsWindow",  winapi_IsWindow },
  { "IsWindowVisible",  winapi_IsWindowVisible },
  { "IsWindowEnabled",  winapi_IsWindowEnabled },
  { "IsChild",  winapi_IsChild },
  { "DestroyWindow",  winapi_DestroyWindow },
  { "ShowWindow",  winapi_ShowWindow },
  { "EnableWindow",  winapi_EnableWindow },
  { "UpdateWindow",  winapi_UpdateWindow },
  { "RedrawWindow",  winapi_RedrawWindow },
  { "SetParent",  winapi_SetParent },
  { "GetParent",  winapi_GetParent },
  { "SetActiveWindow",  winapi_SetActiveWindow },
  { "DrawMenuBar",  winapi_DrawMenuBar },
#if (!defined(UNDER_CE))
  { "CloseWindow",  winapi_CloseWindow },
#endif
  { "MoveWindow",  winapi_MoveWindow },
  { "SetWindowPos",  winapi_SetWindowPos },
#if (!defined(UNDER_CE))
  { "GetWindowPlacement",  winapi_GetWindowPlacement },
#endif
#if (!defined(UNDER_CE))
  { "SetWindowPlacement",  winapi_SetWindowPlacement },
#endif
  { "BringWindowToTop",  winapi_BringWindowToTop },
  { "SetForegroundWindow",  winapi_SetForegroundWindow },
  { "SetFocus",  winapi_SetFocus },
  { "PostMessageW",  winapi_PostMessageW },
  { "SendMessageW",  winapi_SendMessageW },
  { "IsDialogMessageW",  winapi_IsDialogMessageW },
  { "TranslateAcceleratorW",  winapi_TranslateAcceleratorW },
  { "DefWindowProcW",  winapi_DefWindowProcW },
  { "GetWindowLongW",  winapi_GetWindowLongW },
  { "SetWindowLongW",  winapi_SetWindowLongW },
  { "GetDC",  winapi_GetDC },
  { "GetDCEx",  winapi_GetDCEx },
  { "GetWindowDC",  winapi_GetWindowDC },
  { "ReleaseDC",  winapi_ReleaseDC },
  { "BeginPaint",  winapi_BeginPaint },
  { "EndPaint",  winapi_EndPaint },
  { "InvalidateRect",  winapi_InvalidateRect },
  { "ValidateRect",  winapi_ValidateRect },
  { "GetClientRect",  winapi_GetClientRect },
  { "GetWindowRect",  winapi_GetWindowRect },
  { "ClientToScreen",  winapi_ClientToScreen },
  { "ScreenToClient",  winapi_ScreenToClient },
  { "MapWindowPoints",  winapi_MapWindowPoints },
  { "SetCapture",  winapi_SetCapture },
  { "CreateCaret",  winapi_CreateCaret },
  { "HideCaret",  winapi_HideCaret },
  { "ShowCaret",  winapi_ShowCaret },
#if (!defined(UNDER_CE))
  { "GetTopWindow",  winapi_GetTopWindow },
#endif
#if (!defined(UNDER_CE))
  { "GetLastActivePopup",  winapi_GetLastActivePopup },
#endif
  { "GetWindow",  winapi_GetWindow },
  { "RegisterHotKey",  winapi_RegisterHotKey },
  { "UnregisterHotKey",  winapi_UnregisterHotKey },
#if (!defined(UNDER_CE))
  { "DrawCaption",  winapi_DrawCaption },
#endif
#if (!defined(UNDER_CE))
  { "DrawAnimatedRects",  winapi_DrawAnimatedRects },
#endif
  { "EndDialog",  winapi_EndDialog },
  { "GetDlgItem",  winapi_GetDlgItem },
  { "SetDlgItemInt",  winapi_SetDlgItemInt },
  { "GetDlgItemInt",  winapi_GetDlgItemInt },
  { "SetDlgItemTextW",  winapi_SetDlgItemTextW },
  { "GetDlgItemTextW",  winapi_GetDlgItemTextW },
  { "CheckDlgButton",  winapi_CheckDlgButton },
  { "CheckRadioButton",  winapi_CheckRadioButton },
  { "IsDlgButtonChecked",  winapi_IsDlgButtonChecked },
  { "SendDlgItemMessageW",  winapi_SendDlgItemMessageW },
  { "GetNextDlgGroupItem",  winapi_GetNextDlgGroupItem },
  { "GetNextDlgTabItem",  winapi_GetNextDlgTabItem },
  { "GetDlgCtrlID",  winapi_GetDlgCtrlID },
  { "DefDlgProcW",  winapi_DefDlgProcW },
  { "OpenClipboard",  winapi_OpenClipboard },
  { "SetClipboardViewer",  winapi_SetClipboardViewer },
  { "ChangeClipboardChain",  winapi_ChangeClipboardChain },
#if (defined(USE_AYGSHELL))
  { "SHFindMenuBar",  winapi_SHFindMenuBar },
#endif
#if (defined(USE_AYGSHELL))
  { "SHHandleWMActivate",  winapi_SHHandleWMActivate },
#endif
#if (defined(USE_AYGSHELL))
  { "SHHandleWMSettingChange",  winapi_SHHandleWMSettingChange },
#endif
#if (defined(USE_AYGSHELL))
  { "SHFullScreen",  winapi_SHFullScreen },
#endif
#if (defined(USE_AYGSHELL))
  { "SHDoneButton",  winapi_SHDoneButton },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_Show",  winapi_CommandBar_Show },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_AddBitmap",  winapi_CommandBar_AddBitmap },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_InsertComboBox",  winapi_CommandBar_InsertComboBox },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_InsertMenubar",  winapi_CommandBar_InsertMenubar },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_InsertMenubarEx",  winapi_CommandBar_InsertMenubarEx },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_DrawMenuBar",  winapi_CommandBar_DrawMenuBar },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_GetMenu",  winapi_CommandBar_GetMenu },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_AddAdornments",  winapi_CommandBar_AddAdornments },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_AlignAdornments",  winapi_CommandBar_AlignAdornments },
#endif
#if (defined(USE_COMMANDBAR))
  { "CommandBar_Height",  winapi_CommandBar_Height },
#endif
#if (defined(USE_COMMANDBAR))
  { "IsCommandBarMessage",  winapi_IsCommandBarMessage },
#endif
  { NULL, NULL }
};

static const struct luaL_Reg Window_WrapMethods[ ] = {
  { "WrapWindow", Window_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* Region_Typename = "Region";

// push on stack
int lua_pushRegion( lua_State *L, HRGN hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, Region_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HRGN* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HRGN*)lua_newuserdata(L, sizeof(HRGN));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HRGN lua_toRegion( lua_State *L, int idx )
{
  HRGN v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HRGN)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HRGN)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HRGN* ud  = (HRGN*)luaL_checkudata(L, idx, Region_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "Region (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int Region_index(lua_State *L)
{
  HRGN* ud  = (HRGN*)luaL_checkudata(L, 1, Region_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int Region_wrap(lua_State *L)
{
  HRGN handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HRGN)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HRGN)luaL_checkudata(L, -1, Region_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HRGN)lua_tointeger(L, -1);
  }
  
  return lua_pushRegion(L, handle);
}


static const struct luaL_Reg Region_Methods[ ] = {
  { "__index", Region_index},
  { "wrap", Region_wrap },
  { "EqualRgn",  winapi_EqualRgn },
  { "CombineRgn",  winapi_CombineRgn },
  { "OffsetRgn",  winapi_OffsetRgn },
  { "SetRectRgn",  winapi_SetRectRgn },
  { "PtInRegion",  winapi_PtInRegion },
  { "RectInRegion",  winapi_RectInRegion },
  { NULL, NULL }
};

static const struct luaL_Reg Region_WrapMethods[ ] = {
  { "WrapRegion", Region_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* MidiOut_Typename = "MidiOut";

// push on stack
int lua_pushMidiOut( lua_State *L, HMIDIOUT hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, MidiOut_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HMIDIOUT* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HMIDIOUT*)lua_newuserdata(L, sizeof(HMIDIOUT));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HMIDIOUT lua_toMidiOut( lua_State *L, int idx )
{
  HMIDIOUT v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HMIDIOUT)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HMIDIOUT)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HMIDIOUT* ud  = (HMIDIOUT*)luaL_checkudata(L, idx, MidiOut_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "MidiOut (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int MidiOut_index(lua_State *L)
{
  HMIDIOUT* ud  = (HMIDIOUT*)luaL_checkudata(L, 1, MidiOut_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int MidiOut_wrap(lua_State *L)
{
  HMIDIOUT handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HMIDIOUT)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HMIDIOUT)luaL_checkudata(L, -1, MidiOut_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HMIDIOUT)lua_tointeger(L, -1);
  }
  
  return lua_pushMidiOut(L, handle);
}


static const struct luaL_Reg MidiOut_Methods[ ] = {
  { "__index", MidiOut_index},
  { "wrap", MidiOut_wrap },
  { "midiOutGetVolume",  winapi_midiOutGetVolume },
  { "midiOutSetVolume",  winapi_midiOutSetVolume },
  { "midiOutOpen",  winapi_midiOutOpen },
  { "midiOutClose",  winapi_midiOutClose },
  { "midiOutPrepareHeader",  winapi_midiOutPrepareHeader },
  { "midiOutUnprepareHeader",  winapi_midiOutUnprepareHeader },
  { "midiOutShortMsg",  winapi_midiOutShortMsg },
  { "midiOutLongMsg",  winapi_midiOutLongMsg },
  { "midiOutReset",  winapi_midiOutReset },
  { "midiOutCachePatches",  winapi_midiOutCachePatches },
  { "midiOutCacheDrumPatches",  winapi_midiOutCacheDrumPatches },
  { "midiOutGetID",  winapi_midiOutGetID },
  { "midiOutMessage",  winapi_midiOutMessage },
  { NULL, NULL }
};

static const struct luaL_Reg MidiOut_WrapMethods[ ] = {
  { "WrapMidiOut", MidiOut_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* DC_Typename = "DC";

// push on stack
int lua_pushDC( lua_State *L, HDC hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, DC_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HDC* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HDC*)lua_newuserdata(L, sizeof(HDC));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HDC lua_toDC( lua_State *L, int idx )
{
  HDC v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HDC)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HDC)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HDC* ud  = (HDC*)luaL_checkudata(L, idx, DC_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "DC (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int DC_index(lua_State *L)
{
  HDC* ud  = (HDC*)luaL_checkudata(L, 1, DC_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int DC_wrap(lua_State *L)
{
  HDC handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HDC)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HDC)luaL_checkudata(L, -1, DC_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HDC)lua_tointeger(L, -1);
  }
  
  return lua_pushDC(L, handle);
}


static const struct luaL_Reg DC_Methods[ ] = {
  { "__index", DC_index},
  { "wrap", DC_wrap },
  { "DrawFocusRect",  winapi_DrawFocusRect },
  { "DrawEdge",  winapi_DrawEdge },
  { "DrawFrameControl",  winapi_DrawFrameControl },
  { "DrawTextW",  winapi_DrawTextW },
  { "FillRect",  winapi_FillRect },
#if (!defined(UNDER_CE))
  { "FrameRect",  winapi_FrameRect },
#endif
  { "InvertRect",  winapi_InvertRect },
  { "SelectObject",  winapi_SelectObject },
  { "CreateCompatibleDC",  winapi_CreateCompatibleDC },
  { "DeleteDC",  winapi_DeleteDC },
  { "ExcludeClipRect",  winapi_ExcludeClipRect },
  { "IntersectClipRect",  winapi_IntersectClipRect },
  { "GetCurrentObject",  winapi_GetCurrentObject },
#if (!defined(UNDER_CE))
  { "FrameRgn",  winapi_FrameRgn },
#endif
#if (!defined(UNDER_CE))
  { "InvertRgn",  winapi_InvertRgn },
#endif
#if (!defined(UNDER_CE))
  { "PaintRgn",  winapi_PaintRgn },
#endif
  { "SetBkColor",  winapi_SetBkColor },
  { "GetBkColor",  winapi_GetBkColor },
#if (!defined(UNDER_CE))
  { "SetDCBrushColor",  winapi_SetDCBrushColor },
#endif
#if (!defined(UNDER_CE))
  { "GetDCBrushColor",  winapi_GetDCBrushColor },
#endif
#if (!defined(UNDER_CE))
  { "SetDCPenColor",  winapi_SetDCPenColor },
#endif
#if (!defined(UNDER_CE))
  { "GetDCPenColor",  winapi_GetDCPenColor },
#endif
  { "SetBkMode",  winapi_SetBkMode },
  { "GetBkMode",  winapi_GetBkMode },
#if (!defined(UNDER_CE))
  { "SetMapMode",  winapi_SetMapMode },
#endif
#if (!defined(UNDER_CE))
  { "SetPolyFillMode",  winapi_SetPolyFillMode },
#endif
  { "SetTextColor",  winapi_SetTextColor },
  { "SetTextAlign",  winapi_SetTextAlign },
#if (!defined(UNDER_CE))
  { "SetTextJustification",  winapi_SetTextJustification },
#endif
#if (!defined(UNDER_CE))
  { "PtVisible",  winapi_PtVisible },
#endif
  { "RectVisible",  winapi_RectVisible },
#if (!defined(UNDER_CE))
  { "SetViewportExtEx",  winapi_SetViewportExtEx },
#endif
#if (!defined(UNDER_CE))
  { "SetViewportOrgEx",  winapi_SetViewportOrgEx },
#endif
#if (!defined(UNDER_CE))
  { "SetWindowExtEx",  winapi_SetWindowExtEx },
#endif
#if (!defined(UNDER_CE))
  { "SetWindowOrgEx",  winapi_SetWindowOrgEx },
#endif
#if (!defined(UNDER_CE))
  { "OffsetViewportOrgEx",  winapi_OffsetViewportOrgEx },
#endif
#if (!defined(UNDER_CE))
  { "OffsetWindowOrgEx",  winapi_OffsetWindowOrgEx },
#endif
#if (!defined(UNDER_CE))
  { "ScaleViewportExtEx",  winapi_ScaleViewportExtEx },
#endif
#if (!defined(UNDER_CE))
  { "ScaleWindowExtEx",  winapi_ScaleWindowExtEx },
#endif
  { "GetTextExtentExPointW",  winapi_GetTextExtentExPointW },
  { "GetTextExtentPoint32W",  winapi_GetTextExtentPoint32W },
#if (!defined(UNDER_CE))
  { "BeginPath",  winapi_BeginPath },
#endif
#if (!defined(UNDER_CE))
  { "CloseFigure",  winapi_CloseFigure },
#endif
#if (!defined(UNDER_CE))
  { "EndPath",  winapi_EndPath },
#endif
#if (!defined(UNDER_CE))
  { "FillPath",  winapi_FillPath },
#endif
#if (!defined(UNDER_CE))
  { "FlattenPath",  winapi_FlattenPath },
#endif
#if (!defined(UNDER_CE))
  { "PathToRegion",  winapi_PathToRegion },
#endif
#if (!defined(UNDER_CE))
  { "StrokeAndFillPath",  winapi_StrokeAndFillPath },
#endif
#if (!defined(UNDER_CE))
  { "StrokePath",  winapi_StrokePath },
#endif
#if (!defined(UNDER_CE))
  { "WidenPath",  winapi_WidenPath },
#endif
#if (!defined(UNDER_CE))
  { "Arc",  winapi_Arc },
#endif
#if (!defined(UNDER_CE))
  { "ArcTo",  winapi_ArcTo },
#endif
#if (!defined(UNDER_CE))
  { "Chord",  winapi_Chord },
#endif
  { "LineTo",  winapi_LineTo },
  { "MoveToEx",  winapi_MoveToEx },
  { "Ellipse",  winapi_Ellipse },
#if (!defined(UNDER_CE))
  { "Pie",  winapi_Pie },
#endif
  { "Rectangle",  winapi_Rectangle },
  { "RoundRect",  winapi_RoundRect },
#if (!defined(UNDER_CE))
  { "ExtFloodFill",  winapi_ExtFloodFill },
#endif
  { "FillRgn",  winapi_FillRgn },
#if (!defined(UNDER_CE))
  { "FloodFill",  winapi_FloodFill },
#endif
  { "BitBlt",  winapi_BitBlt },
  { "PatBlt",  winapi_PatBlt },
  { "StretchBlt",  winapi_StretchBlt },
#if (!defined(UNDER_CE))
  { "TransparentBlt",  winapi_TransparentBlt },
#endif
#if (!defined(UNDER_CE))
  { "TextOutW",  winapi_TextOutW },
#endif
  { "ExtTextOutW",  winapi_ExtTextOutW },
#if (defined(USE_OPENGL))
  { "wglCreateContext",  winapi_wglCreateContext },
#endif
#if (defined(USE_OPENGL))
  { "wglCreateLayerContext",  winapi_wglCreateLayerContext },
#endif
#if (defined(USE_OPENGL))
  { "wglMakeCurrent",  winapi_wglMakeCurrent },
#endif
#if (defined(USE_OPENGL))
  { "wglUseFontBitmapsA",  winapi_wglUseFontBitmapsA },
#endif
#if (defined(USE_OPENGL))
  { "wglUseFontBitmapsW",  winapi_wglUseFontBitmapsW },
#endif
#if (defined(USE_OPENGL))
  { "SwapBuffers",  winapi_SwapBuffers },
#endif
#if (defined(USE_OPENGL))
  { "wglRealizeLayerPalette",  winapi_wglRealizeLayerPalette },
#endif
#if (defined(USE_OPENGL))
  { "wglSwapLayerBuffers",  winapi_wglSwapLayerBuffers },
#endif
  { "DrawXorBar",  winapi_DrawXorBar },
  { NULL, NULL }
};

static const struct luaL_Reg DC_WrapMethods[ ] = {
  { "WrapDC", DC_wrap },
  { NULL, NULL }
};

// used to identify the type
const char* Midi_Typename = "Midi";

// push on stack
int lua_pushMidi( lua_State *L, HMIDI hdl )
{
  if (NULL == hdl)
  {
    // return nil
    return 0;
  }

  // lookup handle in handle map
  luaL_getmetatable(L, Midi_Typename);
  lua_pushstring(L, "$Handles");
  lua_rawget(L, -2);                      // stack: $Handles | metatable

  lua_pushlightuserdata(L, hdl);
  lua_rawget(L, -2);                      // stack: nil/object | $Handles | metatable

  if (lua_isnil(L, -1))
  {
    HMIDI* ud;
  
    // pop nil value
    lua_pop(L, 1);

    // push userdata
    ud = (HMIDI*)lua_newuserdata(L, sizeof(HMIDI));
    *ud = hdl;                              // stack: object | $Handles | metatable

    // set metatable
    lua_pushvalue(L, -3);
    lua_setmetatable(L, -2);

    // push key/value for lookup table
    lua_pushlightuserdata(L, hdl);
    lua_pushvalue(L, -2);                 // stack: object |  key  | object | $Handles | metatable

    // add item to lookup table
    lua_rawset(L, -4);                    // stack: object | $Handles | metatable
  }

  // cleanup stack (remove $Handles | metatable)
  lua_remove(L, -2);
  lua_remove(L, -2);

  return 1;
}

// get from stack
HMIDI lua_toMidi( lua_State *L, int idx )
{
  HMIDI v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TNIL:
      {
      }
      break;
    case LUA_TLIGHTUSERDATA:
      {
        v = (HMIDI)lua_touserdata(L, idx);
      }
      break;
    case LUA_TNUMBER:
      {
        v = (HMIDI)lua_tointeger(L, idx);
      }
      break;
    case LUA_TUSERDATA:
      {
        HMIDI* ud  = (HMIDI*)luaL_checkudata(L, idx, Midi_Typename);
        v = *ud;
      }
      break;
    default:
      {
        const char *msg = lua_pushfstring(L, "Midi (handle) expected but got %s", luaL_typename(L, idx));
        luaL_argerror(L, idx, msg);
      }
      break;
  }
  return v;
}

// implements __index metamethod (for .handle attribute)
static int Midi_index(lua_State *L)
{
  HMIDI* ud  = (HMIDI*)luaL_checkudata(L, 1, Midi_Typename);

  const char* stridx = lua_tolstring(L, 2, NULL);

  // check for .handle
  if (0 == strcmp(stridx, "handle"))
  {
    lua_pushlightuserdata(L, *ud);
    return 1;
  }
  else
  {
    luaL_getmetafield(L, 1, stridx);
  }

  return 1;
}

// to wrap handle in an object
static int Midi_wrap(lua_State *L)
{
  HMIDI handle = 0;

  if (lua_isnil(L, -1))
  {
    // lua_pushnil(L);
    // return 1;
  }
  else if (lua_islightuserdata(L, -1))
  {
    handle = (HMIDI)(lua_touserdata(L, -1));
  }
  else if (lua_isuserdata(L, -1))
  {
    handle = (HMIDI)luaL_checkudata(L, -1, Midi_Typename);
  }
  else if (lua_isnumber(L, -1))
  {
    handle = (HMIDI)lua_tointeger(L, -1);
  }
  
  return lua_pushMidi(L, handle);
}


static const struct luaL_Reg Midi_Methods[ ] = {
  { "__index", Midi_index},
  { "wrap", Midi_wrap },
  { "midiConnect",  winapi_midiConnect },
  { "midiDisconnect",  winapi_midiDisconnect },
  { NULL, NULL }
};

static const struct luaL_Reg Midi_WrapMethods[ ] = {
  { "WrapMidi", Midi_wrap },
  { NULL, NULL }
};


//////////////////////////////////////////////////////////////////////////
/**

  registers abstractions as Lua types

  @param[in]  L  pointer lua state

*/////////////////////////////////////////////////////////////////////////
void registerAbstractions(lua_State *L)
{
  // register package functions
#if (defined(USE_MSGQUEUE))
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MsgQueue_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, MsgQueue_WrapMethods, 0);
#endif

  luaL_newmetatable(L, MsgQueue_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MsgQueue_Methods, 0);
#else
  luaL_openlib(L, NULL, MsgQueue_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#endif
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Driver_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, Driver_WrapMethods, 0);
#endif

  luaL_newmetatable(L, Driver_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Driver_Methods, 0);
#else
  luaL_openlib(L, NULL, Driver_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, WaveOut_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, WaveOut_WrapMethods, 0);
#endif

  luaL_newmetatable(L, WaveOut_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, WaveOut_Methods, 0);
#else
  luaL_openlib(L, NULL, WaveOut_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MixerObject_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, MixerObject_WrapMethods, 0);
#endif

  luaL_newmetatable(L, MixerObject_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MixerObject_Methods, 0);
#else
  luaL_openlib(L, NULL, MixerObject_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, WaveIn_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, WaveIn_WrapMethods, 0);
#endif

  luaL_newmetatable(L, WaveIn_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, WaveIn_Methods, 0);
#else
  luaL_openlib(L, NULL, WaveIn_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Mixer_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, Mixer_WrapMethods, 0);
#endif

  luaL_newmetatable(L, Mixer_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Mixer_Methods, 0);
#else
  luaL_openlib(L, NULL, Mixer_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MidiStream_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, MidiStream_WrapMethods, 0);
#endif

  luaL_newmetatable(L, MidiStream_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MidiStream_Methods, 0);
#else
  luaL_openlib(L, NULL, MidiStream_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MidiIn_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, MidiIn_WrapMethods, 0);
#endif

  luaL_newmetatable(L, MidiIn_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MidiIn_Methods, 0);
#else
  luaL_openlib(L, NULL, MidiIn_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Icon_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, Icon_WrapMethods, 0);
#endif

  luaL_newmetatable(L, Icon_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Icon_Methods, 0);
#else
  luaL_openlib(L, NULL, Icon_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Window_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, Window_WrapMethods, 0);
#endif

  luaL_newmetatable(L, Window_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Window_Methods, 0);
#else
  luaL_openlib(L, NULL, Window_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Region_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, Region_WrapMethods, 0);
#endif

  luaL_newmetatable(L, Region_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Region_Methods, 0);
#else
  luaL_openlib(L, NULL, Region_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MidiOut_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, MidiOut_WrapMethods, 0);
#endif

  luaL_newmetatable(L, MidiOut_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, MidiOut_Methods, 0);
#else
  luaL_openlib(L, NULL, MidiOut_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, DC_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, DC_WrapMethods, 0);
#endif

  luaL_newmetatable(L, DC_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, DC_Methods, 0);
#else
  luaL_openlib(L, NULL, DC_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Midi_WrapMethods, 0);
#else
  luaL_openlib(L, NULL, Midi_WrapMethods, 0);
#endif

  luaL_newmetatable(L, Midi_Typename);
  lua_pushstring(L, "$Handles");
  lua_newtable(L);
  lua_rawset(L, -3);
//  lua_pushstring(L, "__index");
//  lua_newtable(L);
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, Midi_Methods, 0);
#else
  luaL_openlib(L, NULL, Midi_Methods, 0);
#endif
//  lua_rawset(L, -3);
  lua_pop(L, 1);

}

